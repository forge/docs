== Developing Forge

Now that you've installed JBoss Forge, played with it a bit (either with CLI or JBDS), it's time to quickly develop a real web application and extend it by adding Hibernate Envers. In this section you will execute a JBoss Forge script and learn how to develop add-ons.

=== Developing a Java EE 7 web application in few seconds

As you've seen in the previous section, with Forge you can enter a few commands, and you'll get code generated. With scaffolding you can even quickly generate a set of JSF pages and REST endpoints to have CRUD capabilities. So, even if you type on your keyboard very quickly, how can you develop an entire Java EE 7 web application in a few seconds? The answer is simple: by running a Forge script! 

A forge script is just a file that contains a set of commands. The commands below create a new `Country` entity with a set of fields. As you can see we can even have comments that start with the `#` symbol. You can end you lines with a `;` but you don't have to :

[source, console]
----
#  Country entity
#  ############
jpa-new-entity --named Country ;
jpa-new-field --named isoCode --length 2 --columnName iso_code --not-nullable ;
jpa-new-field --named name --length 80 --not-nullable ;
jpa-new-field --named printableName --length 80 --columnName printable_name --not-nullable ;
jpa-new-field --named iso3 --length 3 ;
jpa-new-field --named numcode --length 3 ;
----

If you save these commands into a file called `country.fsh` then, you just have to execute with : 

[source, console]
----
[cdbookstore]$ run country.fsh
----

You will see Forge executing line by line each command in a few seconds. So what about running a bigger script?

==== The famous Java Petstore is back

The good thing about the http://www.oracle.com/technetwork/java/petstore1-3-1-02-139690.html[Java Petstore] is that we don't have to explain it much: most of us have heard about it. Haven't You? 

image::developing/petstore-splash.png[title="Petstore splash" align="center"]

The Java Petstore was a sample application created by Sun for its http://www.oracle.com/technetwork/java/javaee/blueprints/index.html[Java BluePrints] program. The Java Petstore was designed to illustrate how J2EE (and then Java EE) could be used to develop an eCommerce web application. Yes, the point of the Petstore is to sell pets online. The Petstore had a huge momentum and we started to see plenty of Petstore-like applications flourish. The idea was to build an application with a certain technology. Let's face it, the J2EE version was far too complex using plenty of (today outdated) http://java.sun.com/blueprints/corej2eepatterns/[design patterns]. 

With a single Forge script, you will generate a CRUD application that will let you manage the Pet's back-end catalog. 

==== Executing the script

First of all, download the script from https://github.com/forge/docs/blob/master/tutorials/forge-hol/script/generate.fsh. You can have a look into it. As you can see, the script:

- creates and sets up the project (a Java EE 7 one)
- creates the domain model with entities, embeddables, constraints and enums. Most of the entities have relationships (One-to-One, Many-to-One...) with others
- creates utility classes, exceptions, CDI qualifiers, interceptors
- adds a service layer with EJBs
- scaffolds JSF pages and creates new JSF beans
- generates REST endpoints
- cleans the `pom.xml` to get rid of some dependencies and add new ones

Now execute the script with :

[source, console]
----
[temps]$ run generate.fsh
----

Depending on the location of the script file, you can also run : 

[source, console]
----
[temps]$ run ../../code/script/generate.fsh
----

You will see hundreds of lines of code scrolling. Once the project is successfully created, have a look at the thousands of lines of code (Java, XML, HTML, CSS...) that Forge generated. The only missing feature today in Forge is the ability to generate methods. That's why some classes are just empty (e.g. the service tier). But adding method is in the roadmap. 

And the best of all, is that it works! To build the application, just do it in Forge :

[source, console]
----
[petstore]$ build
----

==== Running the application

Before deploying the application on http://www.wildfly.org/[WildFly] you can grab the SQL script https://github.com/forge/docs/blob/master/tutorials/forge-hol/script/import.sql and copy it to `petstore/src/main/resources`. This will add data to the database.

Then, just deploy the war file into WildFly, go to the URL http://localhost:8080/petstore and you should see the following homepage :

image::developing/petstore-forge.png[title="Petstore home page" align="center"]

Do not hesitate to browse the database content, create new items, remove customers, filter addresses, update categories... JBoss Forge has just created an entire CRUD web application for our domain model dealing with all the many-to-one, one-to-one... relationships.

Also check the REST interfaces. You can use any REST client (such as Postman for example) to GET/POST/PUT/DELETE data to the database. Got to the following URLs to get a clue :

- http://localhost:8080/petstore/rest/customers
- http://localhost:8080/petstore/rest/customers/1000
- http://localhost:8080/petstore/rest/countries
- http://localhost:8080/petstore/rest/countries/1000
- http://localhost:8080/petstore/rest/countries?max=5

==== Looking at the generated code

Now that you've seen it running, it's time to take a break, fill up a cup of coffee and have a look at the code. This is what you will find in the following packages :

- `constraints` : Bean validation constraints.
- `exceptions` : Application exceptions.
- `model`: The entities, embeddables, enums.
- `rest` : The REST endpoint doing GET/POST/PUT/DELETE operations. Also check the `RestApplication` class.
- `security` : Classes for security mater
- `service` : EJB layer
- `util` : Some CDi qualifiers, interceptors, producers
- `view` : JSF backing beans using CDI conversation, extended persistence context
- `webapp` : JSF pages, Bootstrap 2, templates, css files, images

NOTE: Some of the classes that you've seen are empty or not totally implemented. When you go back home and have time to dig this topic, you can check the final application at https://github.com/agoncal/agoncal-application-petstore-ee7

Now that you have a real application up and running, let's use JBoss Forge to extend it by developping a few add-ons and applying them to the Petstore application.

=== Developing Hibernate Envers addon

http://envers.jboss.org/[Hibernate Envers] is a Hibernate core module that enables auditing of persistence classes.
If you want to audit the history of all the changes made to a certain entity or one of its fields during the web
application runtime, you just need to audit that with `@Audited`. Envers will create a separate table for each such
entity, which will hold the changes made to it. +

In this section we will develop a Forge addon with the following features:

* Setup Envers for the following project by adding its dependency to the POM
* Enable auditing an entity by adding the `@Audited` annotation on class level

==== Creating a new Forge addon

Creating a new Forge addon is similar to any new project that you want to create. You can do it manually, you can copy
and modify an existing project of the same type or you can use a wizard to do it for you. We would certainly recommend
using Forge to help you bootstrap everything for several reasons. It knows exactly which dependencies and artifacts
you need as a start so you will not miss anything. Forge will also not create any garbage in your new project. +

Before creating the Envers addon, you need to start Forge. Please make sure that you have followed the instructions
in <<installing-forge>> before that. You can create a new addon if you run the following command in the Forge CLI: +

[source, console]
----
$ project-new --named envers --type addon --topLevelPackage org.jboss.forge.addon --addons org.jboss.forge.addon:javaee,2.12.0.Final
----

If you run Forge from JBDS, open the Forge wizard (Ctrl + 4 or CMD + 4 on Mac) then select _Project: New_ and specify
_envers_ as project name, _org.jboss.forge.addon_ as top level package, enter project location per your preference and
as a Project type select _Forge Addon_:

image::developing/forge-new-project.png[title="Creating new addon project"]

This will create an empty Maven project that has the following artifacts:

* `pom.xml` where the top level package is the group ID and the project name is the artifact ID. Besides the minimum
Forge dependencies, the command will add also those that you have specified with the `--addons` option in the format
<group-id>:<artifact-id>,<version>
* Standard maven directory structure plus the top level package
* *Empty `beans.xml` in the `src/main/resources/META-INF` directory. This is because Forge and its addons strongly
rely on the CDI development model
* `README.asciidoc` file with a standard skeleton for documenting Forge addons

==== Developing the "Envers: Setup" command

The first command that we are going to create will set up Envers for a project. This basically means that the command
will simply add the Envers library dependency to the current project POM. As with the new Forge addon, we can manually
write the command class, copy and modify an existing command or let Forge itself generated it for us. Here we will go
for the third option.

If you are running from the command line interface, type in: +

[source, console]
----
[envers]$ addon-new-ui-command --named EnversSetupCommand --commandName "Envers: Setup" --categories "Auditing"
----

While from the JBDS, after opening the Forge wizard (Ctrl + 4 or CMD + 4 on Mac), you should choose _Addon: New UI Command_
and enter _EnversSetupCommand_ in the Type Name field, _Envers: Setup_ in the Command name field and add _Auditing_ to
the Categories list box: +

image::developing/forge-envers-setup-command.png[title="Creating _Envers: Setup_ command"]

This will generate `EnversSetupCommand` class in the `org.jboss.forge.addon.commands` package (unless you didn't specify
explicitly anything else). Forge makes this class extend `AbstractUICommand`, which provides some basic functionality
like configuring the command name, the command dialog and the command execution. We will go through these in this and
the next few sections. +

The `getMetadata()` method should be already implemented by Forge:

[source, java]
----
   @Override
   public UICommandMetadata getMetadata(UIContext context)
   {
      return Metadata.forCommand(EnversSetupCommand.class).name(
            "Envers: Setup").category(Categories.create("Auditing"));
   }
----

This will basically create a command that can be called _envers-setup_ from the CLI (note the substitution of colons and
spaces by hyphens) and as _Envers: Setup_ in the _Auditing_ category in the Forge wizard +

As the newly created command will not require any input from the user, we will leave the `initializeUI` method empty.
However, in order to implement the command execution, we will need to change a little bit our class. More precisely we
will have to extend from another abstract command class. The rationale behind this is that we want to update the
*current* project POM. Extending `org.jboss.forge.addon.projects.ui.AbstractProjectCommand` instead of `AbstractUICommand` will give us some handy
methods to access and manipulate the project configuration:

[source, java]
----
public class EnversSetupCommand extends AbstractProjectCommand
{
----

We will have to implement two more abstract methods coming from this parent class:

[source, java]
----
   @Override
   protected boolean isProjectRequired() 
   {
      return true;
   }

   @Inject
   private ProjectFactory projectFactory;

   @Override
   protected ProjectFactory getProjectFactory() 
   {
       return projectFactory;
   }
----

The `org.jboss.forge.addon.projects.ProjectFactory` interface is used to create new or obtain references to existing project.

After having specified _Envers: Setup_ as a project command, we can proceed to implementing the `execute` method.
Usually this is called when the user clicks _Finish_ on the command dialog or in our case where we don't require input:
when the user selects the command from the Forge wizard. +

As we mentioned earlier, the command will have to add the Hibernate Envers dependency to the project. We are going to
build the Forge representation of this dependency using the `org.jboss.forge.addon.dependencies.builder.DependencyBuilder` utility methods:

[source, java]
----
   @Override
   public Result execute(UIExecutionContext context) throws Exception
   {
      Dependency dependency = 
            DependencyBuilder.create("org.hibernate")
                             .setArtifactId("hibernate-envers")
                             .setVersion("4.3.6.Final")
                             .setScopeType("provided");
   }

----

Speaking in Maven terms, this is a dependency to artifact with ID +hibernate-envers+, coming from the +org.hibernate+
group, having version 4.3.6.Final and going into the project's _provided_ scope. +

After we have specified our dependency, we will have to add it to the project model. For that purpose we will use the
`org.jboss.forge.addon.projects.dependencies.DependencyInstaller` utility, responsible for installing a given dependency into the project :

[source, java]
----
   @Inject
   private DependencyInstaller dependencyInstaller;
----

Forge 2.0 is based on modular runtime called _Furnace_. The core of Furnace itself is not bound to any development model,
so the addons can decide which of the Furnace implementations it wants to use. We created our addon with the default
configuration which enables the CDI development model. That is why we asked in the code snippet above Forge to provide
us with the dependency installer for the current project build system. +

Now it is time to install our dependency:

[source, java]
----
   @Override
   public Result execute(UIExecutionContext context) throws Exception
   {
      Dependency dependency =
            DependencyBuilder.create("org.hibernate")
                             .setArtifactId("hibernate-envers")
                             .setVersion("4.3.6.Final")
                             .setScopeType("provided");
      dependencyInstaller.install(getSelectedProject(context), dependency);

   }
----

We are using here one of the helper methods provided by the `AbstractProjectCommand`: `getSelectedProject()`. +

Now our job is done, so it is time to report what we did. We do it by returning the result:

[source, java]
----
   @Override
   public Result execute(UIExecutionContext context) throws Exception
   {
      Dependency dependency =
            DependencyBuilder.create("org.hibernate")
                             .setArtifactId("hibernate-envers")
                             .setVersion("4.3.6.Final")
                             .setScopeType("provided");
      dependencyInstaller.install(getSelectedProject(context), dependency);
      return Results.success("Envers was successfully setup for the current project!");
   }
----

This will result in a _SUCCESS_: message in the command line interface and a green popup in the JDBS after our command is
executed. +

Now that we have a command the enables Hibernate Envers, it is time to add another command that will turn on auditing
for a given JPA entity.

==== Adding some UI with the "Envers: Audit entity" command

We will create the class for the new command in the same way that we created the one for "Envers: Setup": with the help
of Forge. If you are running the CLI, then simply type:

[source, console]
----
addon-new-ui-command --named EnversAuditEntityCommand --commandName "Envers: Audit entity" --categories "Auditing"
----

Or alternatively in the JBDS choose _Addon: New UI Command_, enter _EnversAuditEntityCommand_ in the Type Name field,
_Envers: Audit entity_ in the Command name field and add _Auditing_ to the Categories list box: +

image::developing/forge-envers-audit-entity-command.png[title="Creating _Envers: Audit entity_ command"]

Then open the newly created class and make it extend `AbstractProjectCommand` instead of `AbstractUICommand` and also
add the unimplemented methods the way you did it in the setup command. +

This command will have to receive as input the entity class that has to be audited. To achieve this, we need to do two
things:

. Obtain and configure a `org.jboss.forge.addon.ui.input.UIInput` object from Furnace
. Add our input to the `org.jboss.forge.addon.ui.context.UIBuilder` in the `initializeUI` method

Starting from number one, we should add the following member field to our command class:

[source, java]
----
   @Inject
   @WithAttributes(label = "Entity to audit", required = true)
   private UIInput<JavaResource> auditEntity;
----

Here we call our field `auditEntity`. This automatically will add a `--auditEntity` option to our command in the CLI.
The type of the field is `UIInput<JavaResource>`, which means a few things:

* The JBDS integration will create a text box control for the audit entity, while the command line interface will expect
a single unbounded value
* The type of the value for this option should be a file that represents a `JavaResource` (class, interface or enumeration)

We have also specified some additional attributes with the `@WithAttributes` annotation:

* The `label` attribute tells Forge's JBDS integration to override the field name (`auditEntity` in this case) with
_Entity to audit_. This will be the actual label of the text box in the IDE. This will not however change the option
name on the command line
* The `required` attribute will not let the user complete the dialog without entering a value for the entity. The well
known asterisk character will be displayed along the label in JBDS

After we defined the input field, it is time to add it to the command dialog. In order to do that, we should edit the
`initializeUI` method:

[source, java]
----
   @Override
   public void initializeUI(UIBuilder builder) throws Exception
   {
      builder.add(auditEntity);
   }
----

We can tell now Forge to show a _Browse_ button to the right of the input field, which will open the well known
type picker of Eclipse:

[source, java]
----
   @Override
   public void initializeUI(UIBuilder builder) throws Exception
   {
      auditEntity.getFacet(HintsFacet.class).setInputType(InputType.JAVA_CLASS_PICKER);
      builder.add(auditEntity);
   }
----

In Forge you can also set default values for a certain input. This way you can omit specifying its value on the command
line and in the IDE it will be pre-filled in the command dialog. You can do that with the `setDefaultValue` method of the
`UIInput`. In our case the UIInput is generified over the `org.jboss.forge.addon.parser.java.resources.JavaResource` class. So we'll have to check whether the current
selection in the UI (being the CLI or JBDS) is a file that represents a Java type. If yes, we will set it as the default
value of the text field:

[source, java]
----
   @Override
   public void initializeUI(UIBuilder builder) throws Exception
   {
      auditEntity.getFacet(HintsFacet.class).setInputType(InputType.JAVA_CLASS_PICKER);
      Object selection = builder.getUIContext().getInitialSelection().get();
      if (selection instanceof JavaResource)
         auditEntity.setDefaultValue((JavaResource) selection);
      builder.add(auditEntity);
   }
----

Now the UI of the command is ready. We can go on and implement the `execute` method. First we should get the value
entered in the text field and convert it to `JavaResource`. Then we will extract the `JavaClassSource` out of it so
that we can manipulate things like annotations:

[source, java]
----
   @Override
   public Result execute(UIExecutionContext context) throws Exception
   {
      JavaResource javaResource = auditEntity.getValue().reify(JavaResource.class);
      JavaClassSource javaClass = javaResource.getJavaType();

   }
----

Next we will check whether the chosen class has already the `Audited` annotation and if not, will add it to that. At the
end we'll save the new content and will return successful result:

[source, java]
----
   @Override
   public Result execute(UIExecutionContext context) throws Exception
   {
      JavaResource javaResource = auditEntity.getValue().reify(JavaResource.class);
      JavaClassSource javaClass = javaResource.getJavaType();
      if (!javaClass.hasAnnotation("org.hibernate.envers.Audited")) {
         javaClass.addAnnotation("org.hibernate.envers.Audited");
      }
      javaResource.setContents(javaClass);
      return Results.success(
          "Entity " + javaClass.getQualifiedName() + " was successfully audited");
   }
----

But what if the user enters invalid input? This could be a file that does not exist, or is not a class or is not a JPA
entity. We'll implement the `validate(UIValidationContext validator)` method to handle such situations. Whenever it
finds illegal input, it will add a validation error to the `validator` parameter. This will bring an error message if
the command executes in the CLI and in JBDS will disable the Finish button of the dialog, showing the error message in
its well known location. This is how we implement the method:

[source, java]
----
   @Override
   public void validate(UIValidationContext validator)
   {
      super.validate(validator);
      try
      {
         if (!auditEntity.getValue().reify(JavaResource.class).getJavaType()
               .hasAnnotation(Entity.class))
         {
            validator.addValidationError(auditEntity,
                  "The selected class has to be JPA entity");
         }
      }
      catch (FileNotFoundException e)
      {
         validator.addValidationError(auditEntity,
               "You must select existing JPA entity to audit");
      }
   }
----

Finally, we want to avoid some compilation errors in the project where we will run this command. So it should be only
available for execution if the user has called the setup command first, i.e. if the current project has dependency to
Hibernate Envers. You can implement this enabling and disabling in several ways. We will show one of these: by
implementing the `isEnabled` method. There we will again obtain the `DependencyFacet` and will ask it whether the
desired dependency is installed. If this method returns false, the Forge commands wizard will not list the Audit entity
command and it will not be available in the command completion in CLI. This is the implementation:

[source, java]
----
   @Override
   public boolean isEnabled(UIContext context)
   {
      Dependency dependency = DependencyBuilder
                               .create("org.hibernate")
                               .setArtifactId("hibernate-envers")
      return getSelectedProject(context).getFacet(DependencyFacet.class)
               .hasEffectiveDependency(dependency);
   }
----

Our first addon is ready. We can now build it, deploy it and run it on the Java EE project that we created in the
beginning of this chapter.

==== Installing and trying the Envers addon

Once we have our basic functionality, we can build and install our new addon. For that we should use Forge's addons
addon. It has a very handy command: _Addon: Build and install_. You can run it from the command line by just replacing
the spaces with hyphens and removing the colon:

[source, console]
----
addon-build-and-install
----

If you don't specify the `projectRoot` parameter, Forge will look for the sources of your addon in the current folder.
If this is not the intended behavior, in the CLI run the command like that:

[source, console]
----
addon-build-and-install --projectRoot <path-to-the-addon-sources>
----

In JBDS just specify the path in the command dialog:

image::developing/addon-project-root.png[title="Specifying the addon project location"]

This will trigger the Maven build of the addon and if it is successful, Forge will install it in its addon repository.
You don't have to restart the tool after that, it will automatically load the new software once it is deployed. After
you see the success message, you can load the Forge wizard and will see the new command there:

image::developing/forge-envers-setup-command-wizard.png[title="_Envers: Setup_ command in the _Auditing_ category"]

Now you can set Hibernate Envers up and open one of your JPA entities, that you generated before starting to develop
this addon, e.g. Country. You should be able to call now the other command. In the CLI:

[source, console]
----
envers-audit-entity
----

Or in JBDS press Ctrl + 4 (or CMD + 4 on Mac) and then pick the _Envers: Audit entity_ from the wizard. Notice
that the class that you opened in the editor (`org.jboss.forge.hol.petstore.model.Country`) was selected automatically
for you:

image::developing/audit-entity.png[title="_Envers: Audit entity_ command dialog"]

Just hit Enter and the entity will get the `@Audited` annotation. +

Voila! :)

==== Forge configuration and Forge command execution listeners

In this final section of this chapter we will show you some more features that you could use when developing Forge
addons. In order to showcase those, we will add a new requirement to the envers addon. Suppose that we want when we
set it up to state that we want every new JPA entity that we create to be automatically audited. This means that the
Envers: Setup command should be executable more than once, but it should add the Hibernate Envers dependency in the POM
only the first time it was executed. +

So, our first job is to enhance our setup command with UI in the form of a checkbox that asks the user whether they
want their JPA entities to be automatically auditable. We'll use again the familiar `UIInput` class, but this time
we'll generify it with Boolean. This will tell the IDE integration of Forge to automatically create a checkbox:

[source, java]
----
   @Inject
   @WithAttributes(label = "Audit automatically new entities",
      description = "Automatically make an entity auditable after it is created")
   private UIInput<Boolean> enableAutoAudit;
----

Let's now add the checkbox to the command dialog using the `UIBuilder`:

[source, java]
----
   @Override
   public void initializeUI(UIBuilder builder) throws Exception
   {
      builder.add(enableAutoAudit);
   }
----

Next, we are going to make it possible running the setup command numerous times without polluting our POM file with as
many dependencies to Hibernate Envers. For that we are going to use something as familiar - the DependencyFacet:

[source, java]
----
   @Override
   public Result execute(UIExecutionContext context) throws Exception
   {
      Dependency dependency = DependencyBuilder
                     .create("org.hibernate")
                     .setArtifactId("hibernate-envers")
                     .setVersion("4.3.6.Final")
                     .setScopeType("provided");
      if (!getSelectedProject(context).getFacet(DependencyFacet.class)
                                      .hasDirectDependency(dependency))
      {
         dependencyInstaller.install(getSelectedProject(context), dependency);
      }

      return Results.success("Envers was successfully setup for the current project!");
   }
----

Finally we want to tell potentially other addons and commands whether the user wants or not to automatically add
auditing to newly created JPA entities. For that we can use Forge's configuration. It is file based key-value-pair API,
which can be used for storing project or Forge settings. The pairs are stored in .forge_settings file in the project
root directory (this is the only non-project artifact that Forge creates) or in ~/.forge/forge.xml directory
if it is the global Forge configuration. +

In order to get hold of the project configuration, you need to ask the `ConfigurationFacet` for it:
[source, java]
----
      Configuration config = getSelectedProject(context)
               .getFacet(ConfigurationFacet.class)
               .getConfiguration();
----

TIP: the global Forge configuration is available through CDI injection:
[source, java]
----
   @Inject
   private Configuration config;
----

Using the configuration API is straightforward. We can add this line in the `execute` method just before the return
statement and it will add the boolean value of the checkbox to the project configuration file:

[source, java]
----
      config.setProperty("autoAudit", enableAutoAudit.getValue());
----

Now, whenever and wherever we want to find whether the user has decided to automatically audit new JPA entities, we'll
just need to lookup the _autoAudit_ entry in the project configuration. +

We can furthermore enhance the UI of our command by reading the configuration upon building it and finding out what is
the current value of _autoAudit_. Based on that we can change the default value of our checkbox. For example, if the
user has already run the setup command and has checked the checkbox, the next time when they run it, we want it checked
rather than unchecked. As usually we want to take care of the situation when the entry is not available at all, i.e. the
property is null, by providing a default value to the `getBoolean` method:

[source, java]
----
      Configuration config = getSelectedProject(builder)
               .getFacet(ConfigurationFacet.class)
               .getConfiguration();
      enableAutoAudit.setDefaultValue(config.getBoolean("autoAudit", false));
----

Now it is time for the final step in our journey: implementing automatic auditing of JPA entities. What we want now is
every time the user creates a new entity class using Forge's _JPA: New Entity_ command, to instrument that class with
the `@Audited` annotation. +

If you want to react on the execution of a Forge command, you should implement the `CommandExecutionListener`
interface. Its methods give you hooks to the point before a certain command is executed as well as after the execution
completes. There are a couple of methods for the latter: once for successful and another one for erroneous outcome:

[source, java]
----
public class JpaEntityCreationListener implements CommandExecutionListener
{
   @Override public void preCommandExecuted(UICommand uiCommand,
         UIExecutionContext uiExecutionContext)
   {
   }

   @Override public void postCommandExecuted(UICommand uiCommand,
         UIExecutionContext uiExecutionContext, Result result)
   {
   }

   @Override public void postCommandFailure(UICommand uiCommand,
         UIExecutionContext uiExecutionContext, Throwable throwable)
   {
   }
}
----

In our case we'll just want to implement the `postCommandExecuted` method. We want it to do its work only if the
current command is _JPA: New Entity_

[source, java]
----
      String commandName = uiCommand
               .getMetadata(uiExecutionContext.getUIContext())
               .getName();
      if (commandName.equals("JPA: New Entity"))
      {
      }
----

Next we want to get hold of the project configuration to check whether automatic auditing was selected by the user. It
was easy in the `AbstractProjectCommand` descendants to get the selected project with the respective utility method and
then to obtain the configuration facet from there. Now we have to go through the `Projects.getSelectedProject` static
factory method for that. It needs to get a project factory, which luckily we can inject. It would be also safe to check
whether it is null and only then proceed to the entity instrumentation:

[source, java]
----
   @Inject
   private ProjectFactory projectFactory;

   @Override public void postCommandExecuted(UICommand uiCommand,
         UIExecutionContext uiExecutionContext, Result result)
   {
      String commandName = uiCommand
               .getMetadata(uiExecutionContext.getUIContext())
               .getName();
      if (commandName.equals("JPA: New Entity") && projectFactory != null)
      {
         Configuration configuration = Projects
                  .getSelectedProject(projectFactory, uiExecutionContext.getUIContext())
                  .getFacet(ConfigurationFacet.class)
                  .getConfiguration();
      }
   }
----

Now with the `Configuration` instance at hand we can go on and check what the user preference is:
[source, java]
----
         if (configuration.getBoolean("autoAudit", false))
         {
         }
----

We'll finally take advantage of the fact that Forge automatically selects a newly created class as the current
resource. So, we'll get the current selection, we'll cast it to `JavaResource` and we'll basically do the same thing we
did in the _Envers: Audit entity_ command:

[source, java]
----
         if (configuration.getBoolean("autoAudit", false))
         {
            try {
               JavaResource resource = (JavaResource) uiExecutionContext
                        .getUIContext().getSelection().get();
               JavaClassSource javaClass = resource.getJavaType();
               if (!javaClass.hasAnnotation("org.hibernate.envers.Audited")) {
                  javaClass.addAnnotation("org.hibernate.envers.Audited");
               }
               resource.setContents(javaClass);
            } catch (FileNotFoundException fnfe) {
               fnfe.printStackTrace();
            }
         }
----

That's it. You can now try what you have done. +

For your reference, the full source code of the Forge Envers addon can be download from
https://github.com/forge/docs/tree/master/tutorials/forge-hol/envers-addon[here].
